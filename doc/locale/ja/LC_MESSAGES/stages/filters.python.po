# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024
# This file is distributed under the same license as the PDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PDAL 2.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-04 23:14+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../stages/filters.python.rst:4
msgid "filters.python"
msgstr ""

#: ../../stages/filters.python.rst:6
msgid ""
"The **Python Filter** allows `Python`_ software to be embedded in a "
":ref:`pipeline` that allows modification of PDAL points through a "
"`NumPy`_ array.  Additionally, some global :ref:`metadata` is also "
"available that Python functions can interact with."
msgstr ""

#: ../../stages/filters.python.rst:11
msgid ""
"The function must have two `NumPy`_ arrays as arguments, ``ins`` and "
"``outs``. The ``ins`` array represents the points before the "
"``filters.python`` filter and the ``outs`` array represents the points "
"after filtering."
msgstr ""

#: ../../stages/filters.python.rst:17
msgid "Make sure `NumPy`_ is installed in your `Python`_ environment."
msgstr ""

#: ../../stages/filters.python.rst:26
msgid ""
"Each array contains all the :ref:`dimensions` of the incoming ``ins`` "
"point schema.  Each array in the ``outs`` list matches the `NumPy`_ array"
" of the same type as provided as ``ins`` for shape and type."
msgstr ""

#: ../../stages/filters.python.rst:43
msgid ""
"The function must always return `True` upon success. If the function "
"returned `False`, an error would be thrown and the :ref:`pipeline` "
"exited."
msgstr ""

#: ../../stages/filters.python.rst:48
msgid ""
"If you want write a dimension that might not be available, you can "
"specify it with the add_dimension_ option:"
msgstr ""

#: ../../stages/filters.python.rst:55
msgid "To create more than one dimension, this option also accepts an array:"
msgstr ""

#: ../../stages/filters.python.rst:62
msgid ""
"You can also specify the :ref:`type <types>` of the dimension using an "
"``=``. ::"
msgstr ""

#: ../../stages/filters.python.rst:69
msgid "Modification Example"
msgstr ""

#: ../../stages/filters.python.rst:90
msgid ""
"The JSON pipeline file referenced the external `multiply_z.py` `Python`_ "
"script, which scales the ``Z`` coordinate by a factor of 10."
msgstr ""

#: ../../stages/filters.python.rst:104
msgid "Predicates"
msgstr ""

#: ../../stages/filters.python.rst:106
msgid ""
"Points can be retained/removed from the stream by setting true/false "
"values into a special \"Mask\" dimension in the output point array."
msgstr ""

#: ../../stages/filters.python.rst:109
msgid ""
"The example above sets the \"mask\" to true for points that are in "
"classifications 1 or 2 and to false otherwise, causing points that are "
"not classified 1 or 2 to be dropped from the point stream."
msgstr ""

#: ../../stages/filters.python.rst:136
msgid ""
":ref:`filters.range` is a specialized filter that implements the exact "
"functionality described in this Python operation. It is likely to be much"
" faster than Python, but not as flexible. :ref:`filters.python` is the "
"tool you can use for prototyping point stream processing operations."
msgstr ""

#: ../../stages/filters.python.rst:143
msgid ""
"If you want to read a :ref:`pipeline` of operations into a numpy array, "
"the `PDAL Python extension <https://pypi.python.org/pypi/PDAL>`_ is "
"available."
msgstr ""

#: ../../stages/filters.python.rst:148
msgid "Example pipeline"
msgstr ""

#: ../../stages/filters.python.rst:170
msgid "Module Globals"
msgstr ""

#: ../../stages/filters.python.rst:172
msgid ""
"Three global variables are added to the Python module as it is run to "
"allow you to get :ref:`dimensions`, :ref:`metadata`, and coordinate "
"system information. Additionally, the ``metadata`` object can be set by "
"the function to modify metadata for the in-scope :ref:`filters.python` "
":cpp:class:`pdal::Stage`."
msgstr ""

#: ../../stages/filters.python.rst:189
msgid "Setting stage metadata"
msgstr ""

#: ../../stages/filters.python.rst:192
msgid ""
"The name of the output metadata variable has changed from ``metadata`` to"
" ``out_metadata``."
msgstr ""

#: ../../stages/filters.python.rst:194
msgid ""
"Stage metadata can be created by using the ``out_metadata`` dictionary "
"**global** variable. The ``name`` key must be set. The type of the "
"``value`` can usually be inferred, but can be set to one of ``integer``, "
"``nonNegativeInteger``, ``double``, ``bounds``, ``boolean``, "
"``spatialreference``, ``uuid`` or ``string``."
msgstr ""

#: ../../stages/filters.python.rst:199
msgid ""
"Children may be set using the ``children`` key whose value is a list of "
"dictionaries."
msgstr ""

#: ../../stages/filters.python.rst:209
msgid "Passing Python objects"
msgstr ""

#: ../../stages/filters.python.rst:211
msgid ""
"An JSON-formatted option can be passed to the filter representing a "
"Python dictionary containing objects you want to use in your function. "
"This feature is useful in situations where you wish to call "
":ref:`pipeline_command` with substitutions."
msgstr ""

#: ../../stages/filters.python.rst:216
msgid ""
"If we needed to be able to provide the Z scaling factor of `Example "
"Pipeline`_ with a Python argument, we can place that in a dictionary and "
"pass that to the filter as a separate argument. This feature allows us to"
" be able easily reuse the same basic Python function while substituting "
"values as necessary."
msgstr ""

#: ../../stages/filters.python.rst:236
msgid ""
"With that option set, you can now fetch the pdalargs_ dictionary in your "
"Python script and use it:"
msgstr ""

#: ../../stages/filters.python.rst:251
msgid "Standard output and error"
msgstr ""

#: ../../stages/filters.python.rst:253
msgid ""
"A ``redirector`` module is available for scripts to output to PDAL's log "
"stream explicitly. The module handles redirecting ``sys.stderr`` and "
"``sys.stdout`` for you transparently, but it can be used directly by "
"scripts. See the PDAL source code for more details."
msgstr ""

#: ../../stages/filters.python.rst:261
msgid "Options"
msgstr ""

#: ../../stages/filters.python.rst:265
msgid "script"
msgstr ""

#: ../../stages/filters.python.rst:264
msgid ""
"When reading a function from a separate `Python`_ file, the file name to "
"read from."
msgstr ""

#: ../../stages/filters.python.rst:269
msgid "source"
msgstr ""

#: ../../stages/filters.python.rst:268
msgid ""
"The literal `Python`_ code to execute, when the script option is not "
"being used."
msgstr ""

#: ../../stages/filters.python.rst:272
msgid "module"
msgstr ""

#: ../../stages/filters.python.rst:272
msgid "The Python module that is holding the function to run. [Required]"
msgstr ""

#: ../../stages/filters.python.rst:276
msgid "function"
msgstr ""

#: ../../stages/filters.python.rst:275
msgid "The function to call. [Required]"
msgstr ""

#: ../../stages/filters.python.rst:279
msgid "_`add_dimension`"
msgstr ""

#: ../../stages/filters.python.rst:279
msgid ""
"A dimension name or an array of dimension names to add to the pipeline "
"that do not already exist."
msgstr ""

#: ../../stages/filters.python.rst:283
msgid "_`pdalargs`"
msgstr ""

#: ../../stages/filters.python.rst:282
msgid ""
"A JSON dictionary of items you wish to pass into the modules globals as "
"the ``pdalargs`` object."
msgstr ""

#: ../../stages/filter_opts.rst:5
msgid "where"
msgstr ""

#: ../../stages/filter_opts.rst:2
msgid ""
"An :ref:`expression <PDAL expression>` that limits points passed to a "
"filter. Points that don't pass the expression skip the stage but are "
"available to subsequent stages in a pipeline. [Default: no filtering]"
msgstr ""

#: ../../stages/filter_opts.rst:13
msgid "where_merge"
msgstr ""

#: ../../stages/filter_opts.rst:8
msgid ""
"A strategy for merging points skipped by a '`where'` option when running "
"in standard mode. If ``true``, the skipped points are added to the first "
"point view returned by the skipped filter. If ``false``, skipped points "
"are placed in their own point view. If ``auto``, skipped points are "
"merged into the returned point view provided that only one point view is "
"returned and it has the same point count as it did when the filter was "
"run. [Default: ``auto``]"
msgstr ""

