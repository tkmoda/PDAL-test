# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024
# This file is distributed under the same license as the PDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PDAL 2.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-04 23:14+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../stages/filters.cpd.rst:4
msgid "filters.cpd"
msgstr ""

#: ../../stages/filters.cpd.rst:6
msgid ""
"The **Coherent Point Drift (CPD) filter** uses the algorithm of "
":cite:`Myronenko` algorithm to compute a rigid, nonrigid, or affine "
"transformation between datasets.  The rigid and affine are what you'd "
"expect; the nonrigid transformation uses Motion Coherence Theory "
":cite:`Yuille1998` to \"bend\" the points to find a best alignment."
msgstr ""

#: ../../stages/filters.cpd.rst:15
msgid ""
"CPD is computationally intensive and can be slow when working with many "
"points (i.e. > 10,000).  Nonrigid is significantly slower than rigid and "
"affine."
msgstr ""

#: ../../stages/filters.cpd.rst:19
msgid ""
"The first input to the change filter are considered the \"fixed\" points,"
" and all subsequent inputs are \"moving\" points.  The output from the "
"change filter are the \"moving\" points after the calculated "
"transformation has been applied, one point view per input.  Any "
"additional information about the cpd registration, e.g. the rigid "
"transformation matrix, will be placed in the stage's metadata."
msgstr ""

#: ../../stages/filters.cpd.rst:26
msgid "When to use CPD vs ICP"
msgstr ""

#: ../../stages/filters.cpd.rst:28
msgid ""
"Summarized from the `Non-rigid point set registration: Coherent Point "
"Drift "
"<http://graphics.stanford.edu/courses/cs468-07-winter/Papers/nips2006_0613.pdf>`_"
" paper."
msgstr ""

#: ../../stages/filters.cpd.rst:31
msgid ""
"CPD outperforms the ICP in the presence of noise and outliers by the use "
"of a probabilistic assignment of correspondences between pointsets, which"
" is innately more robust than the binary assignment used in ICP."
msgstr ""

#: ../../stages/filters.cpd.rst:35
msgid ""
"CPD does not work well for large in-plane rotation, such transformation "
"can be first compensated by other well known global registration "
"techniques before CPD algorithm is carried out"
msgstr ""

#: ../../stages/filters.cpd.rst:39
msgid "CPD is most effective when estimating smooth non-rigid transformations."
msgstr ""

#: ../../stages/filters.cpd.rst:45
msgid "Examples"
msgstr ""

#: ../../stages/filters.cpd.rst:59
msgid ""
"If method_ is not provided, the cpd filter will default to using the "
"rigid registration method.  To get the transform matrix, you'll need to "
"use the \"metadata\" option of the pipeline command:"
msgstr ""

#: ../../stages/filters.cpd.rst:67
msgid "The metadata output might start something like:"
msgstr ""

#: ../../stages/filters.cpd.rst:86
msgid ""
":ref:`filters.transformation` to apply a transform to other points. "
":ref:`filters.icp` for deterministic binary point pair assignments."
msgstr ""

#: ../../stages/filters.cpd.rst:90
msgid "Options"
msgstr ""

#: ../../stages/filters.cpd.rst:95
msgid "_`method`"
msgstr ""

#: ../../stages/filters.cpd.rst:93
msgid ""
"Change detection method to use. Valid values are \"rigid\", \"affine\", "
"and \"nonrigid\". [Default: \"rigid\"\"]"
msgstr ""

#: ../../stages/filter_opts.rst:5
msgid "where"
msgstr ""

#: ../../stages/filter_opts.rst:2
msgid ""
"An :ref:`expression <PDAL expression>` that limits points passed to a "
"filter. Points that don't pass the expression skip the stage but are "
"available to subsequent stages in a pipeline. [Default: no filtering]"
msgstr ""

#: ../../stages/filter_opts.rst:13
msgid "where_merge"
msgstr ""

#: ../../stages/filter_opts.rst:8
msgid ""
"A strategy for merging points skipped by a '`where'` option when running "
"in standard mode. If ``true``, the skipped points are added to the first "
"point view returned by the skipped filter. If ``false``, skipped points "
"are placed in their own point view. If ``auto``, skipped points are "
"merged into the returned point view provided that only one point view is "
"returned and it has the same point count as it did when the filter was "
"run. [Default: ``auto``]"
msgstr ""

